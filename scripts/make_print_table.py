#!/usr/bin/env python3
"""
Generate or update the ISS-Mimic 3-D print checklist in the wiki.

Features
--------
• Lists every *.stl / *.3mf under 3D_Printing/  (except archive_lofi/*)
• Reads side-car YAML per-part metadata  (qty, material)
• Preserves checkbox state ✓/□ already on the wiki page
• Leaves Qty / Material blank when no meta is found
"""

import argparse, os, pathlib, re, textwrap, yaml
from github import Github         # pip install PyGithub
from tabulate import tabulate      # pip install tabulate
from markdown_it import MarkdownIt # pip install markdown-it-py

# --------------------------------------------------------------------
# Configuration constants
# --------------------------------------------------------------------
REPO          = "ISS-Mimic/Mimic"     # owner/name
PART_ROOT     = "3D_Printing"         # folder with all printable parts
EXCLUDE_DIRS  = {"archive_lofi"}      # sub-folders (under PART_ROOT) to skip

# Mark-down header that will top the generated page
FRONT_MATTER = textwrap.dedent("""\
    <!--
    Auto-generated by make_print_table.py
    Qty & material come from .meta.yml files.
    Checkbox status is preserved across runs.
    -->
    # ISS Mimic – 3-D Printing Checklist

    Tick boxes as you print.  
    To change Qty / Material, edit or add a
    `<partname>.meta.yml` beside the STL/3MF.
    """).rstrip()

# --------------------------------------------------------------------
# CLI args
# --------------------------------------------------------------------
PARSER = argparse.ArgumentParser()
PARSER.add_argument("--wiki-path", default="wiki",
                    help="path to local clone of the wiki repo (default: wiki/)")
PARSER.add_argument("--page",
                    default="Build-Instruction:-3D-Printed-Parts.md",
                    help="markdown file name inside the wiki repo")
ARGS = PARSER.parse_args()

WIKI_FILE = os.path.join(ARGS.wiki_path, ARGS.page)

# --------------------------------------------------------------------
# Authentication
# --------------------------------------------------------------------
TOKEN = os.getenv("GH_PAT") or os.getenv("GITHUB_TOKEN")
GH = Github(TOKEN) if TOKEN else Github()

# --------------------------------------------------------------------
# Helpers
# --------------------------------------------------------------------
def excluded(path: str) -> bool:
    """
    Return True if `path` (repo-relative) lives in one of EXCLUDE_DIRS.
    """
    rel = path[len(PART_ROOT):].lstrip("/")           # "archive_lofi/foo.stl"
    first = rel.split("/", 1)[0].lower()
    return first in EXCLUDE_DIRS

def load_meta(stl_repo_path: str):
    """
    Look for side-car YAML: foo.stl → foo.meta.yml (.yaml) in same dir.
    Returns dict or {}.
    """
    p = pathlib.PurePosixPath(stl_repo_path)
    for ext in (".meta.yml", ".meta.yaml"):
        meta_repo_path = str(p.with_suffix(ext))
        try:
            # GitHub raw blob contents
            blob = GH.get_repo(REPO).get_contents(meta_repo_path, ref="main")
            return yaml.safe_load(blob.decoded_content) or {}
        except Exception:  # file absent or YAML error
            pass
    return {}

def load_existing_checkboxes():
    """
    Parse current wiki page table to get checkbox status.
    Returns dict {filename -> True (checked) / False}.
    """
    if not os.path.isfile(WIKI_FILE):
        return {}
    with open(WIKI_FILE, encoding="utf-8") as f:
        md = f.read()

    md_tokens = MarkdownIt().parse(md)
    rows, capture = [], False
    for tok in md_tokens:
        if tok.type == "table_open":
            capture = True
            continue
        if tok.type == "table_close":
            break
        if capture and tok.type == "tr_open":
            rows.append([])
        if capture and tok.type == "inline":
            rows[-1].append(tok.content.strip())

    # Skip header
    boxes = {}
    for cells in rows[1:]:
        if len(cells) < 4:
            continue
        m = re.match(r"- \[( |x)\] `([^`]+)`", cells[0], re.I)
        if not m:
            continue
        checked = m.group(1).lower() == "x"
        filename = m.group(2)
        boxes[filename] = checked
    return boxes

# --------------------------------------------------------------------
# Collect live part list
# --------------------------------------------------------------------
tree = GH.get_repo(REPO).get_git_tree("main", recursive=True).tree
PARTS = [
    n.path for n in tree
    if n.type == "blob"
    and n.path.startswith(PART_ROOT)
    and not excluded(n.path)
    and n.path.lower().endswith((".stl", ".3mf"))
]

# --------------------------------------------------------------------
# Assemble table rows
# --------------------------------------------------------------------
checkbox_state = load_existing_checkboxes()
rows = []

for repo_path in sorted(PARTS, key=str.lower):
    filename = repo_path.split("/")[-1]
    meta = load_meta(repo_path)

    qty  = str(meta.get("qty", ""))        # blank if not provided
    mat  = meta.get("material", "")

    checked = checkbox_state.get(filename, False)
    checkbox = "- [x]" if checked else "- [ ]"

    rows.append([
        f"{checkbox} `{filename}`",
        qty,
        mat,
        repo_path.replace(f"{PART_ROOT}/", "")
    ])

md_table = tabulate(rows, headers=["Print", "Qty", "Material", "Path in repo"],
                    tablefmt="github")

# --------------------------------------------------------------------
# Write (or overwrite) the wiki page
# --------------------------------------------------------------------
os.makedirs(os.path.dirname(WIKI_FILE), exist_ok=True)
with open(WIKI_FILE, "w", encoding="utf-8") as f:
    f.write(FRONT_MATTER + "\n\n" + md_table + "\n")
