#!/usr/bin/env python3
"""
Generate or update the ISS-Mimic 3-D print checklist in the wiki.

Features
--------
✓ Lists every *.stl / *.3mf under 3D_Printing/   (skips archive_lofi/)
✓ Reads side-car YAML metadata   (<part>.meta.yml → qty, material)
✓ Preserves checkbox state ✓ / □ already on the wiki page
✓ Leaves Qty / Material blank when no meta is found
"""

import argparse, os, pathlib, re, textwrap, yaml
from github import Github              # pip install PyGithub
from tabulate import tabulate          # pip install tabulate
from markdown_it import MarkdownIt     # pip install markdown-it-py

# ────────────────────────────────────────────────────────────────────
# Constants
# ────────────────────────────────────────────────────────────────────
REPO       = "ISS-Mimic/Mimic"
PART_ROOT  = "3D_Printing"
EXCLUDE    = {"archive_lofi"}          # sub-folders under PART_ROOT to skip

FRONT_MATTER = textwrap.dedent("""\
    <!--
    Auto-generated by make_print_table.py
    Qty & material come from .meta.yml files.
    Checkbox status is preserved across runs.
    -->
    # ISS Mimic – 3-D Printing Checklist

    Tick boxes as you print.  
    To change Qty / Material, edit or add a
    `<partname>.meta.yml` beside the STL/3MF.
    """).rstrip()

# ────────────────────────────────────────────────────────────────────
# CLI
# ────────────────────────────────────────────────────────────────────
parser = argparse.ArgumentParser()
parser.add_argument("--wiki-path", default="wiki",
                    help="local clone of the wiki repo (default: wiki/)")
parser.add_argument("--page",
                    default="Build-Instruction:-3D-Printed-Parts.md",
                    help="markdown file inside the wiki repo")
args = parser.parse_args()

WIKI_MD = os.path.join(args.wiki_path, args.page)

# ────────────────────────────────────────────────────────────────────
# Auth
# ────────────────────────────────────────────────────────────────────
TOKEN = os.getenv("GH_PAT") or os.getenv("GITHUB_TOKEN")
gh    = Github(TOKEN) if TOKEN else Github()

# ────────────────────────────────────────────────────────────────────
# Helpers
# ────────────────────────────────────────────────────────────────────
def is_excluded(repo_path: str) -> bool:
    """True if path lives in an excluded first-level sub-directory."""
    rel = repo_path[len(PART_ROOT):].lstrip("/")      # "archive_lofi/foo.stl"
    return rel.split("/", 1)[0].lower() in EXCLUDE

def load_meta(repo_path: str) -> dict:
    """Return dict from <part>.meta.yml / .yaml (or {})."""
    blob_repo = gh.get_repo(REPO)
    p = pathlib.PurePosixPath(repo_path)
    for ext in (".meta.yml", ".meta.yaml"):
        try:
            meta_blob = blob_repo.get_contents(str(p.with_suffix(ext)), ref="main")
            return yaml.safe_load(meta_blob.decoded_content) or {}
        except Exception:
            pass                                  # file absent or invalid YAML
    return {}

def load_checkboxes() -> dict:
    """Return {filename: True/False} for ticked checkboxes on the wiki page."""
    if not os.path.isfile(WIKI_MD):
        return {}
    with open(WIKI_MD, encoding="utf-8") as fh:
        md = fh.read()

    rows, capture = [], False
    for tok in MarkdownIt().parse(md):
        if tok.type == "table_open":
            capture = True; continue
        if tok.type == "table_close":
            break
        if capture and tok.type == "tr_open":
            rows.append([])
        if capture and tok.type == "inline":
            rows[-1].append(tok.content.strip())

    boxes = {}
    for cells in rows[1:]:                         # skip header
        if len(cells) < 4:
            continue
        m = re.match(r"- \[( |x)\] `([^`]+)`", cells[0], re.I)
        if m:
            boxes[m.group(2)] = (m.group(1).lower() == "x")
    return boxes

# ────────────────────────────────────────────────────────────────────
# Gather part list
# ────────────────────────────────────────────────────────────────────
tree = gh.get_repo(REPO).get_git_tree("main", recursive=True).tree
parts = [
    n.path for n in tree
    if n.type == "blob"
       and n.path.startswith(PART_ROOT)
       and not is_excluded(n.path)
       and n.path.lower().endswith((".stl", ".3mf"))
]

# ────────────────────────────────────────────────────────────────────
# Build rows
# ────────────────────────────────────────────────────────────────────
checkboxes = load_checkboxes()
rows       = []

for repo_path in sorted(parts, key=str.lower):
    fname = repo_path.split("/")[-1]
    meta  = load_meta(repo_path)

    qty  = str(meta.get("qty", ""))      # blank if not set
    mat  = meta.get("material", "")

    checked  = checkboxes.get(fname, False)
    checkbox = "- [x]" if checked else "- [ ]"

    rows.append([
        f"{checkbox} `{fname}`",
        qty,
        mat,
        repo_path.replace(f"{PART_ROOT}/", "")
    ])

md_table = tabulate(rows,
                    headers=["Print", "Qty", "Material", "Path in repo"],
                    tablefmt="github")

# ────────────────────────────────────────────────────────────────────
# Write wiki page
# ────────────────────────────────────────────────────────────────────
os.makedirs(os.path.dirname(WIKI_MD), exist_ok=True)
with open(WIKI_MD, "w", encoding="utf-8") as fh:
    fh.write(FRONT_MATTER + "\n\n" + md_table + "\n")
